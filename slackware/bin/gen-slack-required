#!/usr/bin/perl
use warnings;
use strict;

our $VERSION = '0.5.8';

# TODO	: detect interpreted languages
#	  (*) Java
#	  ( ) Python
#	  ( ) Perl
#	Until then, individual build scripts will have to insert this
#	themselves.

use File::Find		qw/ find /;
use File::Basename	qw/ basename /;
use Cwd			qw/ abs_path /;
use File::LibMagic	qw//;
use Getopt::Std		qw/ getopts /;
use Storable		qw/ lock_store retrieve /;

# settings for temporary storage (this greatly speeds up processing)
use constant CACHE_STORE_DIR	=> "$ENV{'HOME'}/.cache";
use constant CACHE_STORE	=> CACHE_STORE_DIR . '/slackpacks.pdata';

use constant PACKAGE_PATH	=> '/var/log/packages';
use constant SHLIB_MIME		=> 'application/x-sharedlib; charset=binary';
use constant EXEC_MIME		=> 'application/x-executable; charset=binary';

my @JAVA_DEPS = (
	# these are ambiguous between jre/jdk and gcc-java
	#'/usr/lib/libjvm.so',
	#'/usr/lib64/libjvm.so',

	'/usr/lib/java/lib/i386/libjava.so',
	'/usr/lib/java/jre/lib/i386/libjava.so',
	'/usr/lib64/java/lib/amd64/libjava.so',
	'/usr/lib64/java/jre/lib/amd64/libjava.so',
);

# because:
#  * sometimes gcc-c++ and cxxlibs have different files for of libstdc++
#  * aaa_elflibs / freetype same thing
# TODO : this is extremely hacky and subject to breakage
my @LIB_EQUIVALENTS = (
	# libstdc++
	[ qw#
		/usr/lib/libstdc++.so.6.0.14
		/usr/lib/libstdc++.so.6.0.16
		/usr/lib/libstdc++.so.6.0.17
		/usr/lib/libstdc++.so.6.0.18
	# ],
	[ qw#
		/usr/lib64/libstdc++.so.6.0.14
		/usr/lib64/libstdc++.so.6.0.16
		/usr/lib64/libstdc++.so.6.0.17
		/usr/lib64/libstdc++.so.6.0.18
	# ],

	# libcurl
	[ qw#
		/usr/lib/libcurl.so.4.2.0
		/usr/lib/libcurl.so.4.3.0
	# ],
	[ qw#
		/usr/lib64/libcurl.so.4.2.0
		/usr/lib64/libcurl.so.4.3.0
	# ],

	# libfreetype
	[ qw#
		/usr/lib/libfreetype.so.6.2.2
		/usr/lib/libfreetype.so.6.8.0
		/usr/lib/libfreetype.so.6.9.0
		/usr/lib/libfreetype.so.6.10.0
	# ],
	[ qw#
		/usr/lib64/libfreetype.so.6.2.2
		/usr/lib64/libfreetype.so.6.8.0
		/usr/lib64/libfreetype.so.6.9.0
		/usr/lib64/libfreetype.so.6.10.0
	# ],

	# libpng
	[ qw#
		/usr/lib/libpng14.so.14.5.0
		/usr/lib/libpng14.so.14.8.0
		/usr/lib/libpng14.so.14.9.0
		/usr/lib/libpng14.so.14.12.0
		/usr/lib/libpng.so.3.44.0
		/usr/lib/libpng.so.3.47.0
	# ],
	[ qw#
		/usr/lib64/libpng14.so.14.5.0
		/usr/lib64/libpng14.so.14.8.0
		/usr/lib64/libpng14.so.14.9.0
		/usr/lib64/libpng14.so.14.12.0
		/usr/lib64/libpng.so.3.44.0
		/usr/lib64/libpng.so.3.47.0
	# ],

	# zlib
	[ qw#
		/usr/lib/libz.so.1.2.5
		/usr/lib/libz.so.1.2.6
		/usr/lib/libz.so.1.2.8
		/lib/libz.so.1.2.5
		/lib/libz.so.1.2.6
		/lib/libz.so.1.2.8
	# ],
	[ qw#
		/usr/lib64/libz.so.1.2.5
		/usr/lib64/libz.so.1.2.6
		/usr/lib64/libz.so.1.2.8
		/lib64/libz.so.1.2.5
		/lib64/libz.so.1.2.6
		/lib64/libz.so.1.2.8
	# ],

	# libtiff
	[ qw#
		/usr/lib/libtiff.so.3.9.4
		/usr/lib/libtiff.so.3.9.6
	# ],
	[ qw#
		/usr/lib64/libtiff.so.3.9.4
		/usr/lib64/libtiff.so.3.9.6
	# ],

	# libldap
	[ qw#
		/usr/lib/libldap-2.4.so.2.5.6
		/usr/lib/libldap-2.4.so.2.8.3
	# ],
	[ qw#
		/usr/lib64/libldap-2.4.so.2.5.6
		/usr/lib64/libldap-2.4.so.2.8.3
	# ],

	# liblzma
	[ qw#
		/lib/liblzma.so.5.0.4
		/lib/liblzma.so.5.0.5
	# ],
	[ qw#
		/lib64/liblzma.so.5.0.4
		/lib64/liblzma.so.5.0.5
	# ],

	# libusb
	[ qw#
		/usr/lib/libusb-1.0.so.0.0.0
		/usr/lib/libusb-1.0.so.0.1.0
	# ],
	[ qw#
		/usr/lib64/libusb-1.0.so.0.0.0
		/usr/lib64/libusb-1.0.so.0.1.0
	# ],

	# glib2
	[ qw#
		/usr/lib/libglib-2.0.so.0.3200.4
		/usr/lib/libglib-2.0.so.0.3400.3
		/usr/lib/libglib-2.0.so.0.3600.4
		/usr/lib/libglib-2.0.so.0.3901.0
	# ],
	[ qw#
		/usr/lib64/libglib-2.0.so.0.3200.4
		/usr/lib64/libglib-2.0.so.0.3400.3
		/usr/lib64/libglib-2.0.so.0.3600.4
		/usr/lib64/libglib-2.0.so.0.3901.0
	# ],
	[ qw#
		/usr/lib/libgmodule-2.0.so.0.3200.4
		/usr/lib/libgmodule-2.0.so.0.3400.3
		/usr/lib/libgmodule-2.0.so.0.3600.4
		/usr/lib/libgmodule-2.0.so.0.3901.0
	# ],
	[ qw#
		/usr/lib64/libgmodule-2.0.so.0.3200.4
		/usr/lib64/libgmodule-2.0.so.0.3400.3
		/usr/lib64/libgmodule-2.0.so.0.3600.4
		/usr/lib64/libgmodule-2.0.so.0.3901.0
	# ],
	[ qw#
		/usr/lib/libgobject-2.0.so.0.3200.4
		/usr/lib/libgobject-2.0.so.0.3400.3
		/usr/lib/libgobject-2.0.so.0.3600.4
		/usr/lib/libgobject-2.0.so.0.3901.0
	# ],
	[ qw#
		/usr/lib64/libgobject-2.0.so.0.3200.4
		/usr/lib64/libgobject-2.0.so.0.3400.3
		/usr/lib64/libgobject-2.0.so.0.3600.4
		/usr/lib64/libgobject-2.0.so.0.3901.0
	# ],
	[ qw#
		/usr/lib/libgthread-2.0.so.0.3200.4
		/usr/lib/libgthread-2.0.so.0.3400.3
		/usr/lib/libgthread-2.0.so.0.3600.4
		/usr/lib/libgthread-2.0.so.0.3901.0
	# ],
	[ qw#
		/usr/lib64/libgthread-2.0.so.0.3200.4
		/usr/lib64/libgthread-2.0.so.0.3400.3
		/usr/lib64/libgthread-2.0.so.0.3600.4
		/usr/lib64/libgthread-2.0.so.0.3901.0
	# ],

);
# coalesce it into an easier format using a fuck-it-just-have-it-all-to-all
# relationship
my %_LIB_EQUIVALENTS = map {
	my $equiv_buff = $_;
	my @tuples;
	foreach my $lib (@{$equiv_buff}) {
		push @tuples, $lib, $equiv_buff;
	}
	@tuples
} @LIB_EQUIVALENTS;

# regex for packages you DO NOT WANT showing up in the slack-required
my $BLACKLIST = '^fglrx';

my %opts = (
	'v'	=> 0,
	'o'	=> '-',
	'a'	=> 0,
	'm'	=> '',
	'M'	=> '',
);

&getopts('vo:am:M:', \%opts);

sub HELP_MESSAGE {
	my $fh = shift;
	print $fh <<EOF
Usage: $0 [OPTIONS] DIRECTORY...
Generate a `slack-required' file for use in a Slackware package.

  -v			Print verbose message on STDERR.
  -o FILE		Output slack-required to FILE.
			  `-' is a synonym for STDOUT (default).
  -a			Automatic detection of where to output slack-required.
  -m REGEX		Only match package names matching REGEX.
  -M REGEX		Exclude package names matching REGEX.

Attempts are made to detect and exclude from the generated listing the package
name that DIRECTORY represents by examining the names of the `usr/doc/*'
directories and the contents of `install/slack-desc'.

If DIRECTORY is not specified, then the current directory is used.

Copyright (C) 2010-2011 Dan Church.
License GPLv3+: GNU GPL version 3 or later (http://gnu.org/licenses/gpl.html).
This is free software: you are free to change and redistribute it. There is NO
WARRANTY, to the extent permitted by law.
EOF
;
	exit 0;
}

# correct relative paths
# OR if no directories given, search the current directory
push @ARGV, $ENV{'PWD'} unless map { s#^([^/])#$ENV{'PWD'}/$1# } @ARGV;

# automatic output file detection
if ($opts{'a'} && (! length $opts{'o'} or $opts{'o'} eq '-')) {
	foreach my $dir (@ARGV) {
		if (-d "${dir}/install" && -w _) {
			$opts{'o'} = "${dir}/install/slack-required";
			last;
		}
	}

	if ($opts{'v'}) {
		unless (length $opts{'o'} and $opts{'o'} ne '-') {
			print STDERR "Automatic detection of output file failed; outputting to STDOUT\n";
		} else {
			print STDERR "Automatically writing slack-required to file `$opts{'o'}'\n";
		}
	}
}

# dynlib magic checker
my $magic = File::LibMagic->new;

sub read_dynlib_deps {
	(my $elfbin = shift)
		# shell-escape argument for inclusion in non-interpolated
		# single quotes (probably not necessary, as shared libraries
		# rarely have /\W/ in their filenames, but you can never be
		# sure)
		=~ s/'/'\\''/g;

	# make sure ldd(1) outputs messages in English by setting LC_MESSAGES
	# to C
	((my $lcm_backup), $ENV{'LC_MESSAGES'}) =
	($ENV{'LC_MESSAGES'}, 'C');
	# use ldd(1) to read dynamic library links
	open my $ldd, '-|', "ldd '$elfbin'"
		or die "cannot open pipe from ldd(1) on file `$elfbin': $!";
	# restore environment
	$ENV{'LC_MESSAGES'} = $lcm_backup if defined $lcm_backup;

	my @lib_deps;

	foreach my $ldd_line (<$ldd>) {
		# TODO : subject to breakage
		if ($ldd_line =~ /^\s*(\S+\s+=>\s)?(\S+)\s/) {
			# description of lines output by ldd(1):
			#
			# "[LIBBASENAME] => [LIBABS] ([HEX STRING])"
			#	rpath-specified dynamic library link
			# "[LIBABS] ([HEX STRING])"
			#	absolute path (-L) -specified library link
			#
			# where `LIBABS' is an absolute path to a shared
			# library, and `LIBBASENAME' is the basename of a
			# shared library that is located and loaded at runtime
			#
			# example lines:
			#
			# libm.so.6 => /lib64/libm.so.6 (0x00007f354b6ea000)
			# /lib64/ld-linux-x86-64.so.2 (0x00007f354b96d000)
			#
			# note: if a library is not found, it will print a
			# double-space in place of like so:
			#
			# linux-vdso.so.1 =>  (0x00007fff235ff000)
			#
			# this is why the `\s' in the first parenthetical
			# pattern is not scaled

			# follow all symlinks to the absolute file name
			push @lib_deps, &abs_path($2);
		}
	}

	close $ldd;

	\@lib_deps
}

sub read_package {
	my ($package_file, $location_data) = @_;

	my $package_name = &basename($package_file);
	open my $pkg, '<', $package_file
		or die "cannot open package file `$package_file' for reading: $!";

	# skip lines until we get to the meat of the package
	until (<$pkg> =~ m/^FILE LIST:$/) {}

	foreach my $instfile (<$pkg>) {
		chomp $instfile;

		next unless $instfile;

		# translate package directory file to installed path
		$instfile = &package_to_installed($instfile);

		# skip directories & common meta-info files
		next if &is_in_skipped_path($instfile);

		# follow all symlinks to the absolute file name (returns the
		# same path if file isn't found)
		$instfile = &abs_path($instfile);

		next unless $instfile;

		# TODO : this is hackish
		# find out equivalent installed libraries
		my @equivs = &lib_equivalents($instfile);

		# add to location hash
		foreach my $loc ($instfile, @equivs) {
			$location_data->{$loc} = []
				unless exists $location_data->{$loc};
			push @{$location_data->{$loc}}, $package_name;
		}
	}

	close $pkg;

	$location_data
}

sub package_to_installed {
	my $instfile = shift;

	# convert from internal package name into absolute path name
	$instfile = "/$instfile";

	# sometimes vital system libraries will be installed to an `incoming'
	# directory before being moved to their homes
	$instfile =~ s#^(/lib(64)?/)incoming/#$1#;

	# lots of times, files installed in /etc and /var/lib/games will be
	# given a `.new' extension and moved when the package is installed
	$instfile =~ s#^(/etc/|/var/lib/games/)(.+)\.new#$1$2#;

	$instfile
}

sub is_in_skipped_path {
	my $file_in_package = shift;

	! $file_in_package or
	#$file_in_package =~ m#(^/(install|etc|dev|usr/(man|doc|info|src|include|s?bin|share/(doc|man|locale|info|icons|pixmaps|applications)))|\.packlist$)#
	# let's try this
	$file_in_package !~ m#\.so#
}

sub is_in_this_package {
	my ($file, $jaildir) = @_;

	defined $jaildir and defined $file and -f "$jaildir/$file"
}

sub is_dynlib {
	my $file = shift;

	# compare mimetype of file against expected mimetype of shared library
	$file = &abs_path($file);

	$magic->checktype_filename($file) eq SHLIB_MIME
}

sub is_executable {
	my $file = shift;

	# compare mimetype of file against expected mimetype of ELF executable
	$file = &abs_path($file);

	$magic->checktype_filename($file) eq EXEC_MIME
}

sub is_java {
	my $file = shift;

	$file =~ /\.(jar|class)$/;
}

sub add_deps {
	my ($deps, $pdata, @libs) = @_;

	foreach my $libfile (@libs) {
		next unless defined $libfile and length $libfile;
		$deps->{$libfile} = {} unless exists $deps->{$libfile};
		if (exists $pdata->{$libfile}) {
			@{$deps->{$libfile}}{@{$pdata->{$libfile}}} =
				(1) x @{$pdata->{$libfile}};
		} else {
			print STDERR "dependency lib `$libfile' not found in any package\n" if $opts{'v'};
			#use Data::Dumper; print STDERR Data::Dumper->Dump([$libfile]);
		}
	}
}

sub lib_equivalents {
	my @equivs; # start with what we already know
	foreach my $lib (@_) {
		if (exists $_LIB_EQUIVALENTS{$lib}) {
			push @equivs, @{$_LIB_EQUIVALENTS{$lib}};
		} else {
			# it's equivalent to itself
			push @equivs, $lib;
		}
	}
	@equivs
}

# XXX: BEGIN Data storage/retrieval/maintenance functions {{{

sub get_package_data {
	# determine if we need to re-read package data, or if we can use the
	# cached data

	my $package_data;

	unless (-d CACHE_STORE_DIR) {
		# does not exist yet, so we don't need to do anything; an empty
		# undef will be returned
		mkdir CACHE_STORE_DIR;
	} else {
		my $packages_mtime = (stat scalar PACKAGE_PATH)[9];
		my $cache_mtime = 0;

		if (-f CACHE_STORE) {
			$cache_mtime = (stat scalar CACHE_STORE)[9];

		} else {
			printf STDERR '(creating cache in %s)...',
				CACHE_STORE
				if $opts{'v'};

			# `touch' the file by storing an empty hash ref in it
			&lock_store({}, CACHE_STORE);
			# set the time stamp
			#utime time, $packages_mtime, CACHE_STORE;
		}

		if ($packages_mtime < $cache_mtime) {
			print STDERR '(cached)...' if $opts{'v'};
			$package_data = &retrieve(CACHE_STORE);

			# invalidate the cache if it's newer than this script
			unless (defined $package_data->{'version'} and
				$package_data->{'version'} eq $VERSION) {
				print STDERR '(cache is invalid, regenerating)...'
					if $opts{'v'};
					$package_data = &update_package_data({});
					&lock_store($package_data, CACHE_STORE);
			}
		} else {
			# outdated (or non-existent) cache;
			# it's going to have to be updated
			print STDERR '(updating cache)...' if $opts{'v'};
			$package_data = &update_package_data($package_data);
			&lock_store($package_data, CACHE_STORE);
		}
	}

	# only interested in the location hash (->{'times'} is for updating)
	$package_data->{'locations'}
}

sub update_package_data {
	my $old_package_data = shift;
	my $new_package_data = {};

	my ($locations, $times) = (
		$old_package_data->{'locations'}	|| {},
		$old_package_data->{'times'}		|| {},
	);

	&find(
		sub {
			my $packfile = $File::Find::name;
			return unless
				-f $packfile and

				# ignore files currently in a state of being
				# upgraded (upgradepkg(8) installs new packages
				# first, then moves the *-upgraded-* file to
				# /var/log/removed_packages)
				$packfile !~ m#-upgraded-# and

				# ignore hidden files (binary file [for
				# instance a Vim .swp file] will cause the
				# program to hang)
				$packfile !~ m#.*/\.[^/]+$#;

			my $packname = &basename($packfile);
			my $pack_mtime = (lstat $packfile)[9];
			if (! exists $times->{$packname} or
				$pack_mtime != $times->{$packname}) {
				# needs to be read

				&read_package(
					$packfile,
					$locations
				);

				$times->{$packname} = $pack_mtime;
			}
		},
		PACKAGE_PATH
	);

	# place new data inside of the old structure
	@{$new_package_data}{qw/ locations times version /} =
		($locations, $times, $VERSION);

	# clear out old data
	&clean_package_data($new_package_data);

	$new_package_data
}

sub clean_package_data {
	my $packdata = shift;

	my ($times, $locations) = @{$packdata}{qw/ times locations /};

	# determine what references packages no longer exist
	# (as a hash for searching purposes)
	my %old_packnames = map {
		(! -f PACKAGE_PATH . '/' . $_) ?
			($_, 1) :
			()
	} keys %{$times};

	# eliminate old references in times
	delete @{$times}{(keys %old_packnames)};

	# eliminate old references in locations
	foreach my $libname (keys %{$locations}) {
		# reconstruct the list of referenced packages, cutting out the
		# names of the old packages
		$locations->{$libname} = [
			grep { ! exists $old_packnames{$_} }
			@{$locations->{$libname}}
		];

		# delete libraries with no referenced packages
		delete $locations->{$libname}
			unless scalar @{$locations->{$libname}};
	}
}

# XXX: END Data storage/retrieval/maintenance functions }}}

sub find_deps {
	my ($pdata, @searchdirs) = @_;

	my %deps;

	foreach my $jail (@searchdirs) {
		&find(
			sub {
				my $execfile = $File::Find::name;

				if (-f $execfile) {
					my $lddeps;
					if (&is_dynlib($execfile) ||
						&is_executable($execfile)) {

						$lddeps = &read_dynlib_deps($execfile);
					} elsif (&is_java($execfile)) {
						$lddeps = [ map {&abs_path($_)} @JAVA_DEPS ];
					}

					# eliminate files in this jail
					$lddeps = [ grep {
						! &is_in_this_package($_, $jail)
					} @{$lddeps} ];

					&add_deps(\%deps, $pdata, @{$lddeps});
				}
			},
			$jail
		);
	}

	\%deps
}

# XXX: BEGIN Output functions {{{

sub format_slack_required {
	my ($deps, $current_package) = @_;

	# collate package name dependencies
	#my %pack_deps_coverage;
	my %pack_deps;
	foreach my $lib_deps (values %{$deps}) {
		# eliminate blacklisted packages
		my @pks = grep {
			# note: if `-m' is not specified or is blank, this will
			# match
			m#$opts{'m'}# and
			!(length $opts{'M'} and m#$opts{'M'}#) and
			!(length $BLACKLIST and m#$BLACKLIST#)
		} keys %{$lib_deps};

		next unless @pks;
		#@pack_deps_coverage{@pks} = (1) x @pks;

		# translate the package data to text like `package >= 0.3.5'
		# and hash to ensure no duplicates
		my %coverage =
			map {($_,1)}
			&packname_to_dep($current_package, @pks);

		# format the package line for multiply-met dependencies (i.e.
		# two packages provide the same library)
		my $pack_line = join ' | ', sort keys %coverage;

		# hash it to make sure there are no repeats
		$pack_deps{$pack_line} = 1
			if length $pack_line;
	}

	my $s_req_contents = join "\n", sort keys %pack_deps;

	$s_req_contents
}

sub packname_to_dep {
	my ($current_package, @package_names) = @_;
	my @depstrs;

	foreach my $pack_str (@package_names) {
		# (...packname...)-(version)-(arch)-(build)
		my @pack_parts = reverse split /-/, $pack_str;
		if (@pack_parts > 3) {
			# can extract package name and version
			my ($pver, @pname_parts) =
				@pack_parts[2 .. $#pack_parts];

			my $pname = join '-', reverse @pname_parts;

			# eliminate current package from listing
			next if $current_package and
				$pname =~ /^${current_package}$/;

			# get rid of `_multilib' specifiers
			# also, eliminate revision-based versions
			$pver =~ s/(_multilib|^r\d+)$//;

			if (length $pver) {
				push @depstrs,
					(sprintf "%s >= %s", $pname, $pver);

				# XXX : Workaround for jre/jdk dep
				if ($pname eq 'jre') {
					push @depstrs,
					(sprintf "%s >= %s", 'jdk', $pver);
				} elsif ($pname eq 'jdk') {
					push @depstrs,
					(sprintf "%s >= %s", 'jre', $pver);
				}
			} else {
				# bare dependency
				# (unknown version or unstable revision)
				push @depstrs, $pname;
			}
		}
	}

	@depstrs
}

# XXX: END Output functions }}}

sub determine_current_package {
	my @package_paths = @_;

	my @package_name_candidates;

	&find(
		sub {
			my $fn = $File::Find::name;
			if (-d $fn && $fn =~ m#usr/doc/([^/]+)$#) {
				my @pnp = split /-/, $1;
				push @package_name_candidates,
					(join '-', @pnp[0 .. ($#pnp - 1)]);
			} elsif (-f $fn && $fn =~ m#/slack-desc$#) {
				if (open my $fh, '<', $fn) {
					# higher priority (unshift)
					unshift @package_name_candidates,
						(map {
							/^(\S+):/ ?
								($1) :
								()
						} <$fh>)[0];
				}
			}
		},
		@package_paths
	);

	$package_name_candidates[0]	
}

# main operation function
#
# arguments:
#	1: output file
#	2-inf: search directories for files in package
sub generate_slack_required {
	my ($required_out, @dep_searchdirs) = @_;

	my $current_package = &determine_current_package(@dep_searchdirs);

	print STDERR "Using '$current_package' as current package name\n"
		if $opts{'v'} and $current_package;

	print STDERR "Scanning package contents..." if $opts{'v'};
	my $package_contents = &get_package_data;
	
	print STDERR "done\nFinding dependencies..." if $opts{'v'};
	my $all_deps = &find_deps($package_contents, @dep_searchdirs);

	print STDERR "done\n" if $opts{'v'};

	my $slack_required_contents = &format_slack_required($all_deps, $current_package);

	print STDERR "=== contents of slack-required ===\n",
		$slack_required_contents, "\n",
		"=== end of slack-required ===\n"
			if $opts{'v'};

	if (length $slack_required_contents) {
		# only write to file if there is content to be written
		# (this prevents writing an empty slack-required file)

		$required_out = \*STDOUT
			unless defined $required_out and
			length $required_out and
			$required_out ne '-';

		unless (ref $required_out eq 'GLOB') {
			open my $required_fh, '>', $required_out
				or die "cannot open file `$required_out' for writing: $!";
			$required_out = $required_fh;
		}

		print $required_out "$slack_required_contents\n";

		close $required_out;
	}
}

&generate_slack_required($opts{'o'}, @ARGV);
