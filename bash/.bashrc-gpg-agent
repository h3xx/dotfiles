# .bashrc-gpg-agent

# start gpg-agent

#gpg_envf="${HOME}/.gpg-agent-info"
#gpg_sock="${HOME}/.gnupg/S.gpg-agent"
#gpg_vars='GPG_AGENT_INFO SSH_AUTH_SOCK SSH_AGENT_PID'

# condition 1:	[outcome 1]
#  gpg-agent was started from this session
# condition 2:	[outcome 3]
#  gpg-agent has not been started
# condition 3:	[outcome 2]
#  gpg-agent is running but a different session started it
# condition 4:	[outcome 3]
#  gpg-agent was running, but was killed
# condition 5:	[outcome 4]
#  the environment file was altered

# outcome 1:
#  do not start gpg-agent; use the shell environment
# outcome 2:
#  do not start gpg-agent; load environment from file
# outcome 3:
#  start gpg-agent, saving environment file and shell environment
# outcome 4:
#  kill gpg-agent and execute [outcome 3]

# (gpg-agent is setup [in ~/.gnupg/gpg-agent.conf], to use the same
# socket every time and write the same environment file every time)


# sock_use | has_envf | env | action
# 0	   | x	      | x   | start
# 1	   | 0	      | 0   | restart
# 1	   | 0	      | 1   | na
# 1	   | 1	      | 0   | load envf
# 1	   | 1	      | 1   | na

#if [[ ! -f "$gpg_envf" -o "$gpg_envf" -nt "$gpg_sock" ]]; then
#	# env file was altered; possible security breach
#	killall -s KILL -u "$USER" -v -w gpg-agent
#	killall -s KILL -u "$USER" -q -w gpg-agent
#	unset $gpg_vars
#fi

#eval "$(
#	umask -S u=rwx,g=,o=
#	# test before starting to avoid log clutter
#	if fuser -s "$gpg_sock" 2>/dev/null; then
#		(cat "$gpg_envf" && echo "export $gpg_vars")
#	else
#		gpg-agent
#	fi
#)"
#
#unset gpg_envf gpg_sock gpg_vars

##### KEEP IT SIMPLE STUPID! #####
# (from gpg-agent man page)
if [[ -f ~/.gpg-agent-info ]]; then
	. ~/.gpg-agent-info
	export GPG_AGENT_INFO
	export SSH_AUTH_SOCK
fi
