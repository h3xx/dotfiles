# .bashrc-progcomp

# Turn on programmable completion
shopt -s progcomp

# BEGIN BUILTINS
# make directory commands see only directories
#complete -d pushd

# bg completes with stopped jobs
# (addendum: job names not always good/legal)
#complete -A stopped -P '%' bg

# Other job commands
# (addendum: job names not always good/legal)
#complete -j -P '%' fg jobs disown wait
complete -F _jobspecs -P '%' fg bg jobs disown wait \
	j

# readonly and export complete with shell variables
complete -v export readonly

# unset also completes with shell variables, but also function names
complete -v -A function unset

# set completes with set options
complete -A setopt set

# shopt completes with shopt options
complete -A shopt shopt

# Builtin help topics
complete -A helptopic help

# alias and unalias complete with aliases
complete -a alias unalias

# bind completes with readline bindings (make this more intelligent)
complete -A binding bind

# type and which complete on commands
complete -c \
	type which \
	killall pidof \
	ka startall stopall

# builtin completes on builtins
complete -b builtin

# enable completes on disabled builtins
complete -A disabled enable

# END BUILTINS

# BEGIN USER FUNCTIONS
# user commands see only users
complete -u su usermod userdel passwd \
	chage chfn groups w \
	finger talk write

# Group commands see only groups
complete -g groupmod groupdel newgrp

# Here are some notes on tests I performed. You're welcome.
#
# Positional parameters:
#
# $1: program name
# $2: word before cursor
# $3: previous word
#
# For instance, hitting tab at this point:
#
# $ foo bar ba|z blarg
#   |-| |-| ||
#   $1  $3  $2
#
# will produce ('foo' 'ba' 'bar').
#
# Whereas:
#
# $ foo bar baz |blarg
#
# will produce ('foo' '' 'bar').
#
# Builtin variables:
#
# ${COMP_WORDS[$COMP_CWORD]}:
#	The full word under the cursor at the time tab was pressed. Sometimes it
#	will be empty. The easiest way I can think of to describe it is to imagine
#	the cursor as a block, the insertion point being at the left side of the
#	block. This variable holds the value of the word TOUCHING the edge of the
#	cursor block, or if there are two, the one touching the LEFT side.
# $COMP_LINE:
#	A string containing everything sitting on the command line, spaces and all.
# $COMP_KEY:
#	The ordinal value of the character pressed to invoke completion. Tab is
#	$'\x9', so most of the time it will be `9'.
# $COMP_POINT:
#	The number character at which the cursor sits in relation the beginning of
#	the command line. Ranges from 0 to ${#COMP_LINE}. Beware of indented lines,
#	as this does not measure from the beginning of the beginning of the
#	command.

_jobspecs() {
	readarray -t COMPREPLY < <(
		readarray JOBLINES < <(
			[[ $1 = 'bg' ]] && jobs -s || jobs
		)

		for JOBSPEC in "${JOBLINES[@]/]*}" ; do
			# truth
			# srch	| match	| ret
			# 0	| x	| 1
			# 1	| 0	| 0
			# 1	| 1	| 1
			# ret = !srch || match
			[[ -z ${2:1} || ${JOBSPEC:1} = "${2:1}"* ]] &&
			echo -n "${JOBSPEC:1} "
		done

		# add job command names
		compgen -j -X '('
	)

	# this works but it uses too many external programs
	#read -a COMPREPLY <<EOF
#$(jobs $([ -z "${1/bg}" ] && echo '-s') |cut -c 2 |grep "^${2//%/}" |tr '\n' ' ')
#EOF
}

# module removal commands only see installed modules
complete -F _instkmods rmmod
_instkmods() {
	readarray -t COMPREPLY < <(
		cut -f 1 -d ' ' /proc/modules |
		grep "^$2"
	)
}

# module insertion commands see only modules
complete -o default -F _kmods insmod modprobe
_kmods() {
	readarray -t COMPREPLY < <(
		find "/lib/modules/$(uname -r)/" \
			-type f \
			\( -name "$2*.ko" -exec basename -- {} .ko \; \) -o \
			\( -name "$2*.ko.gz" -exec basename -- {} .ko.gz \; \) |
			sort -u
	)
}

# man completes on manual page names
# TODO: use $MANPATH and $LANG settings
complete -o default -F _manpages man
_manpages() {
	[[ ${COMP_WORDS[1]} = */* ]] && return
	readarray -t COMPREPLY < <(
		COMP_WORDBREAKS=
		if [[ $COMP_CWORD -gt 1 ]]; then
			SECT=${COMP_WORDS[1]}
		else
			SECT='[0-9]'
		fi
		shopt -s nullglob

		MANS=('/usr/man/man'${SECT}"/${2}"*.${SECT}*)
		MANS=("${MANS[@]#/usr/man/man[0-9]/}")
		IFS=$'\n'
		echo -n "${MANS[*]%.[0-9]*}"
	)
}

# umount only sees mounted file systems
complete -o default -F _mounts umount df
_mounts() {
	readarray -t COMPREPLY < <(
		cut -f 2 -d ' ' /proc/mounts |
		grep "^$2"
	)
}

# pkg-config
complete -o default -F _pkg_config pkg-config
_pkg_config() {
	local \
		PKG_FILES=() \
		PKG_PATH

	for PKG_PATH in ${PKG_CONFIG_PATH//:/ }; do
		PKG_FILES+=("$PKG_PATH/$2"*.pc)

		# No star globs
		[[ -f ${PKG_FILES[$((${#PKG_FILES[*]}-1))]} ]] ||
		unset PKG_FILES[$((${#PKG_FILES[*]}-1))]
	done

	# Basenames
	PKG_FILES=("${PKG_FILES[@]##*/}")

	COMPREPLY=(
		# Strip .pc
		"${PKG_FILES[@]%.pc}"
	)
}

# swapoff
complete -o default -F _swaps swapoff
_swaps() {
	readarray -t COMPREPLY < <(
		/sbin/swapon -s |
		grep -o "^${2:-/}[^ ]*"
	)
}

# slackware packages
if [[ $UID -eq 0 && -d /var/log/packages ]]; then
	complete -o default -F _slackpacks removepkg
	_slackpacks() {
		readarray -t COMPREPLY < <(
			shopt -s nullglob
			cd /var/log/packages
			m=("$2"*)
			IFS=$'\n'
			echo "${m[*]%-+([^-])-+([^-])-+([^-])}"
		)
	}
fi

# psql sees users after -U
if [[ -f ~/.pgpass ]]; then
	complete -o default -F _psqlcomp psql
	_psqlcomp() {
		readarray -t COMPREPLY < <(
			cut -f 4 -d ':' ~/.pgpass |
			grep "^$2"
		)
	}
fi

complete -F _artisan artisan art
_artisan() {
	COMP_WORDBREAKS=${COMP_WORDBREAKS//:}
	local COMMANDS=$(
		while [[ $PWD != / ]]; do
			if [[ -e artisan ]]; then
				php artisan --raw --no-ansi list | cut -f 1 -d ' '
				break
			fi
			cd ..
		done
	)
	readarray -t COMPREPLY < <(
		compgen -W "$COMMANDS" -- "${COMP_WORDS[$COMP_CWORD]}"
	)
}


# gio
complete -o default -F _gio gio
_gio() {
	local CMD
	if [[ $COMP_CWORD -eq 1 || ${COMP_WORDS[1]} = help ]]; then
		for CMD in \
			cat copy help info list mime mkdir monitor mount move open remove rename save set trash tree version \
			; do
			if [[ $CMD = "$2"* ]]; then
				COMPREPLY+=("$CMD")
			fi
		done
	fi
}

# turn on git programmable completion, if installed
test -n "$(
	for fn in \
		/usr/share/bash-completion/completions/git \
		/usr/doc/git-*.*.*/contrib/completion/git-completion.bash \
		; do
		if [[ -f $fn ]]; then
			echo "$fn"
			break
		fi
	done
)" && {
	. "$_" || continue
	# Add alias completions that git-completion.bash isn't smart enough to
	# figure out
	_git_diff_wrapper() {
		_git_diff "$@"
	}
	_git_merge_into() {
		__git_complete_refs --dwim --mode=heads "$@"
	}
	_git_reset_wrapper() {
		_git_reset "$@"
	}
	# also complete git refs for tig
	__git_complete tig __git_complete_revlist
}

# bash completion for gpg
# Source (modified): https://salsa.debian.org/debian/bash-completion/-/blob/master/completions/gpg
# License: GPL-2.0
_gpg() {
	local \
		CUR=${COMP_WORDS[$COMP_CWORD]} \
		PREV=${COMP_WORDS[$COMP_CWORD-1]} \

	case "$PREV" in
		--sign | --clearsign | --decrypt-files | --load-extension | -!(-*)s)
			# Complete default (files and dirs)
			return
			;;
		--export | --sign-key | --lsign-key | --nrsign-key | --nrlsign-key | --edit-key)
			# return list of public keys
			readarray -t COMPREPLY < <(
				compgen -W "$(
					$1 --list-keys 2>/dev/null |
					sed -ne 's@^pub.*/\([^ ]*\).*$@\1@p' \
						-ne 's@^.*\(<\([^>]*\)>\).*$@\2@p'
				)" -- "$CUR"
			)
			return
			;;
		--recipient | -!(-*)r)
			readarray -t COMPREPLY < <(
				compgen -W "$(
					$1 --list-keys 2>/dev/null |
					sed -ne 's@^.*<\([^>]*\)>.*$@\1@p'
				)" -- "$CUR"
			)
			if [[ -e ~/.gnupg/gpg.conf ]]; then
				# Append
				readarray -t -O ${#COMPREPLY[@]} COMPREPLY < <(
					compgen -W "$(
						sed -ne 's@^[ \t]*group[ \t][ \t]*\([^=]*\).*$@\1@p' \
							~/.gnupg/gpg.conf
					)" -- "$CUR"
				)
			fi
			return
			;;
	esac

	if [[ $CUR = -* ]]; then
		readarray -t COMPREPLY < <(
			compgen -W '$($1 --dump-options)' -- "$CUR"
		)
	fi
} &&
complete -F _gpg -o default gpg

# XXX : debugging function
#_listcomp() {
#	local VARNAME
#	COMPREPLY=()
#	for VARNAME in 1 2 COMP_LINE COMP_POINT COMP_KEY COMP_TYPE COMP_CWORD COMP_WORDBREAKS; do
#		COMPREPLY+=("$VARNAME:'$(eval "echo \${$VARNAME}")'")
#	done
#	COMPREPLY+=("COMP_WORDS:$(IFS="|"; echo "${COMP_WORDS[*]}")")
#}

# END USER FUNCTIONS

# BEGIN NETWORK FUNCTIONS
#complete -A hostname host nmap ping traceroute ssh ftp telnet
# END NETWORK FUNCTIONS

# BEGIN PID FUNCTIONS
# END PID FUNCTIONS

# BEGIN FILE ASSOCIATIONS
# END FILE ASSOCIATIONS
