#!/usr/bin/perl -w
use strict;

our $VERSION = 0.06;

=pod

=head1 NAME

fxpr - command-line calculator with floating-point support

=head1 SYNOPSIS

fxpr [OPTION]... EXPRESSION

=head1 DESCRIPTION

The above explanation is only a half-truth. In actuality, `fxpr' is a I<Perl
expression evaluator>. It is I<much> more powerful than a simple calculator,
though it can still be used as one.

The name is based on expr(1), the command-line integer expression evaluator.

For supported operations, see the L<perlop(1)> man page.

Since fxpr evaluates raw expressions, and being that Perl is a pretty powerful
language, please, for fuck's sake B<be careful> about the expressions you pass
this program. I will not be held responsible for any damage.

=head1 OPTIONS

=over

=item B<-U>

Use Unicode mode for output (see L<perlunifaq(1)>).

=item B<-f> I<FORMAT>

Use FORMAT as the printf(3)-compatible string to format the output. For
instance:

    $ fxpr -f '%08x' '255<<8'
    0000ff00

=item B<-m> I<FORMAT>

Use FORMAT as the printf(3)-compatible string for outputting elements in
matrices. This is usually determined by examining the length of the data
involved.

    $ fxpr '0.05 * mat [1,2]'
    [ 0.05 0.10 ]
    $ fxpr -m '%0.1f' '0.05 * mat [1,2]'
    [ 0.1 0.1 ]

=item B<--help>

Display this help and exit.

=item B<--version>

Output version information and exit.

=back

=cut

##### XXX : libraries #####

use Getopt::Std		qw/ getopts /;
use Term::ANSIColor	qw/ colored :constants /;

# mathematical constants
use Math::GSL::Const	qw/ :all /;

use constant PI		=> $M_PI;
use constant E		=> $M_E;

##### XXX : option processing #####

sub HELP_MESSAGE {
	require Pod::Text;
#	use File::Basename	qw/ basename /;
#	my ($fh, $name) = (shift, &basename($0));
#	print $fh <<EOF
#Usage: $name [OPTION] EXPRESSION
#Simple command-line calculator with floating-point support.
#
#  -f [FORMAT]	printf-compatible output formatting
#
#Expressions are evaluated like Perl syntax, and the last returned value is what
#is printed.
#
#Mathematical constants are also supported through Math::GSL. See
#Math::GSL::Const for a complete list.
#EOF
#	;

	my ($fh, $pod) = (
		shift ||
		$Getopt::Std::OUTPUT_HELP_VERSION ||
		\*STDERR,
		Pod::Text->new
	);

	$pod->parse_from_file($0, $fh);

	exit 0;
}

sub VERSION_MESSAGE {
	use File::Basename	qw/ basename /;
	my ($fh, $name) = (
		shift ||
		$Getopt::Std::OUTPUT_HELP_VERSION ||
		\*STDERR,
		&basename($0)
	);

	# only output version information if called with `--version'
	&HELP_MESSAGE($fh) unless $2 eq 'version';

	print $fh <<EOF
$name $VERSION
Copyright (C) Dan Church
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Dan Church <amphetamachine\@gmail.com>
EOF
	;
	exit 0;
}

my %opts = (
	'U'	=> 0,
	'f'	=> '%s',
	'm'	=> '',
);

&getopts('Uf:m:', \%opts) or &HELP_MESSAGE;

=head1 CONSTANTS

Some constants are defined for use in expressions:

=over

=item B<E>

Euler's number (2.7182818...).

=item B<PI>

Pi, as in circumference divided by twice the radius (3.1415927...).

=back

This list also includes all of the mathematical constants defined in
L<Math::GSL::Const>, which are too numerous to list here.

=head1 FUNCTIONS

Some functions have been implemented in order to automate some processes.

=head2 D(@things)

Returns the textual representation of a Perl data structure, as generated by
L<Data::Dumper>. This is mainly useful for debugging.

    $ fxpr 'D 0..2'
    $VAR1 = 0;
    $VAR2 = 1;
    $VAR3 = 2;

    $ fxpr 'D [reverse 3..5]'
    $VAR1 = [
	5,
	4,
	3
    ];


=cut

sub D {
	require Data::Dumper;
#	Data::Dumper->Dump([@_], [map {"thing${_}"} 1 .. $#_ + 1])

#	my @dump_lines = Data::Dumper->Dump([@_]);
#	wantarray ? @dump_lines : join '', @dump_lines;

#	join '', Data::Dumper->Dump([@_]);

	Data::Dumper->Dump([@_]);
}

=head2 avg(@list)

Averages a list of numbers. Works on really L</big> numbers.

    $ fxpr 'avg 1, 8, 1'
    5

=cut

sub avg {
	# note: `/ @_' here would interfere with Math::GSL's operation
	# overloads; apparently dividing a matrix by X is not the same as
	# multiplying it by 1/X.
	#&sum(@_) / @_

	&sum(@_) * (1 / (@_ || 1))
}

=head2 big($number_as_string...)

Returns either a L<Math::BigInt> or a L<Math::BigFloat> object based on whether
the argument contains a decimal point. This is useful for computations that
are too large for the processor.

    $ fxpr '999_999_999_999_999_999_999_999 + 1' # too big
    1e+24
    $ fxpr 'big("999_999_999_999_999_999_999_999") + 1'
    1000000000000000000000000

=cut

sub big {
	require Math::BigFloat;
	require Math::BigInt;
	my @bigs = map {
#		ref eq 'SCALAR' ?
		length ref $_ ?
			$_ :
			/\./ ?
				Math::BigFloat->new($_) :
				Math::BigInt->new($_)
	} @_;

	wantarray ? @bigs : $bigs[0]
}

=head2 dur($int...)

Alias for one of my favorite functions, L<Time::Duration>'s duration_exact().
Due to how L<Time::Duration> was implemented, this works on really L</big>
numbers.

    $ fxpr 'dur 3665 85'
    1 hour, 1 minute, and 5 seconds
    1 minute and 25 seconds

Also see the L</t> function.

=cut

sub dur {
	use Time::Duration	qw/ duration_exact /;
	my @durs = map {
		&duration_exact($_)
	} @_;

	wantarray ? @durs : join "\n", @durs
}

=head2 permute($arrayref)

Gives all permutations of a given set of elements. Stolen straight out of B. Heap's HeapPermute algorithm.

    $ fxpr 'permute [0..1]'
    [ 0 1 ]
    [ 1 0 ]
    $ fxpr 'permute [0..2]'
    [ 0 1 2 ]
    [ 1 0 2 ]
    [ 2 0 1 ]
    [ 0 2 1 ]
    [ 1 2 0 ]
    [ 2 1 0 ]

=cut

sub permute {
	my ($alphabet, $n, $current_set, $sets) = @_;

	$sets = [] unless defined $sets;
	$current_set = [ @{$alphabet} ] unless defined $current_set;
	$n = @{$alphabet} unless defined $n;

	if ($n == 1) {
		push @{$sets}, [ @{$current_set} ];
	} else {
		foreach my $i (0 .. ($n-1)) {
			&permute($alphabet, $n-1, $current_set, $sets);
			if ($n % 2) {
				# n is odd
				($current_set->[0], $current_set->[$n-1]) =
				($current_set->[$n-1], $current_set->[0]);
			} else {
				# n is even
				($current_set->[$i], $current_set->[$n-1]) =
				($current_set->[$n-1], $current_set->[$i]);
			}
		}
	}

	@{$sets}
}

=head2 fact($value...)

Finds the factorial of the value.

    $ fxpr 'fact 6'
    720
    $ fxpr 'fact -3'
    -6

=cut

sub fact {
	my @effs;

	foreach my $val (@_) {
		push @effs, 1;
		$effs[-1] *= $_
			for ($val < 0) ?
				$val .. -1 :
				1 .. $val;
	}

	wantarray ? @effs : $effs[0]
}

=head2 hr_size($byte_count...)

Returns the human-readable size of the given byte counts (in base 1024, not SI
units), within a threshold of 0.1.

The even-indexed return values are the calculated numeric component, and the
odd-indexed values are the abbreviated unit names.

    $ fxpr 'hr_size 900'
    900 B
    $ fxpr 'hr_size 992' # past 1024*0.9, so use next unit
    0.96875 KB

Works for units up to yottabytes (1,208,925,819,614,629,174,706,176 [= 1024 **
8] bytes).

=cut

sub hr_size {
	# make sure it's a Math::BigFloat object (BigInt causes bugs)
	my $sz = &big((int shift) . '.0');
	my @sizes = qw/ B KB MB GB TB PB EB ZB YB /;
	my $fact = &big('1024.0'); # again, integer math causes bugs here
	my $thresh = 0.1;
	my @ret;
	foreach my $exp (reverse 0 .. $#sizes) {
		my $factexp = $fact->copy;
		$factexp->bpow($exp);
		if ($sz > (1 - $thresh) * $factexp) {
			@ret = ($sz / $factexp, $sizes[$exp]);
			last;
		}
	}

	# default to [SIZE] bytes
	@ret = ($sz, $sizes[0]) unless @ret;

	wantarray ? @ret : join ' ', @ret[0, 1];
}

=head2 mat($value...)

=head2 mat([@vector]...)

=head2 mat([ [ @matrix_row ], [ @matrix_row ]... ]...)

Creates L<Math::GSL::Matrix> objects, in the third example, filling unspecified
values to make the matrix a consistent size. Specifying an empty row will cause
there to be a row of zeroes.

All of the other functions support matrix operations, so this can lead to some
pretty powerful calculations:

    $ fxpr 'avg mat [0..5], [1..6]'
    [ 0.5 1.5 2.5 3.5 4.5 5.5 ]

See the B<L</-m>> option for specifying a pattern for the individual elements.

=cut

sub mat {
	use Math::GSL::Matrix	qw/ :all /;
	# (slurp onto @inputs)
	my (@inputs, @mats) = (@_);

#	if (ref $inputs[0] ne 'ARRAY') {
#		# user passed just plain numbers; interpret that as a simple
#		# vector
#		@inputs = ([@_]);
#	}

	foreach my $m (@inputs) {
		my ($rows, $cols, $data);

		if (ref $m ne 'ARRAY') {
			# 1 x 1 matrix from scalar value
			($rows, $cols, $data) = (1, 1, [ [ $m ] ]);
		} elsif (ref $m->[0] ne 'ARRAY') {
			# 1 x ? vector from simple array ref
			($rows, $cols, $data) = (1, scalar @{$m}, [ $m ]);
		} else {
			# ? x ? matrix from complex array ref

			# measure size of matrix
			($rows, $cols) = (
				(scalar @{$m}),
				(sort {$b <=> $a} map {scalar @{$_}} @{$m})[0],
			);

			# append zeroes to rows less than $cols in size
			$data = [ map {
				[ @{$_}, (0) x ($cols - @{$_}) ]
			} @{$m} ];

		}

		my $mat = Math::GSL::Matrix->new($rows, $cols);
		$mat->set_row($_, $data->[$_]) foreach 0 .. $#{$data};

		push @mats, $mat
	}

	wantarray ? @mats : $mats[0]
}

=head2 sigm(@list)

Performs the logistic curve sigmoid function, which is:

              1
    P(t) = --------
           1 + e^-t

=cut

sub sigm {
	my @s = map { 1 / (1 + $M_E ** -$_) } @_;

	wantarray ? @s : $s[0]
}


=head2 sum(@list)

Sums some numbers. Works on really L</big> numbers.

    $ fxpr 'sum 1..3'
    6

=cut

sub sum {
	my $sum = shift;
	$sum += $_ for @_;
	$sum
}

=head2 t($time_string)

Converts time strings like those recognized by sleep(1) into seconds.

    $ fxpr 't "18m4s"'
    1084
    $ fxpr 't "12d40m12s"'
    1039212
    $ fxpr 't "m-3s"'
    57

Negative numbers are allowed. The numeric portion is optional and defaults to
C<1>.

Years (C<"y">) are counted as 365 days and weeks (C<"w">) are 7 days.

Appending C<"t"> or C<"[NUMBER]t"> to the string will result in the current
UNIX Epoch timestamp being added to the result.

=cut

sub t {
	my %mults = (
		't'	=> time,
		's'	=> 1,
		'm'	=> 60,
		'h'	=> 3600,
		'd'	=> 86400,
		'w'	=> 604800,
		'y'	=> 31536000,
	);

	my @times;

	foreach my $ts (@_) {
		my $ts_sum = 0;

		foreach my $tp ($ts =~ /(-?\d*\D)/g) {
			my ($td, $m) = ($tp =~ /(-?\d*)(\D)/);
			$ts_sum += $mults{$m} * ($td || 1)
				if exists $mults{$m};
		}

		push @times, $ts_sum;
	}

	wantarray ? @times : $times[0]
}

=head2 comma($number)

Inserts commas at the thousands separators. Works on really L</big> numbers.

    $ fxpr 'comma 3456789.2'
    3,456,789.2
    $ fxpr 'comma big(2) ** 128'
    340,282,366,920,938,463,463,374,607,431,768,211,456

=cut

sub comma {
	my @vals = map {
		my $y = /(\..*)$/ ? $1 : '';
		(my $z = reverse int) =~ s#(.{3})#$1,#g;
		($z = reverse $z) =~ s#^,##;
		$z . $y
	} @_;

	wantarray ? @vals : $vals[0]
}

=head2 red($text...)

=head2 yellow($text...)

=head2 blue($text...)

=head2 cyan($text...)

=head2 green($text...)

=head2 magenta($text...)

=head2 black($text...)

=head2 bold($text...)

Colors text using L<Term::ANSIColor> and returns it. Can be combined.

    $ fxpr 'red "dark red text"'

    $ fxpr 'bold red "bright red text"'

=cut

# scalable wrapper function for Term::ANSIColor::colored
sub _colored {
	my $color = shift;
	map {&colored($_, $color)} &_to_strings(@_)
}

sub red	{ &_colored(qw/ red	/, @_) }
sub yellow	{ &_colored(qw/ yellow	/, @_) }
sub blue	{ &_colored(qw/ blue	/, @_) }
sub cyan	{ &_colored(qw/ cyan	/, @_) }
sub green	{ &_colored(qw/ green	/, @_) }
sub magenta	{ &_colored(qw/ magenta	/, @_) }
sub black	{ &_colored(qw/ black	/, @_) }
sub bold	{ &_colored(qw/ bold	/, @_) }

##### XXX : input expression evaluation #####

my @expr;

{
	# turn off strict syntax for evaluating the expression
	no strict;

	@expr =	&_to_strings(eval "@ARGV");
}

# switch on Unicode I/O (see perlunifaq(1))
binmode STDOUT, ':utf8'
	if $opts{'U'};

printf "$opts{'f'}\n", $_
	for @expr;

# wrapper function for converting things to strings
sub _to_strings {
	&_mat_to_string(&_arrayref_to_string(@_))
}

sub _mat_to_string {

	my @out;

	foreach my $m (@_) {
		if (ref $m eq 'Math::GSL::Matrix') {

			my $elem_pat;

			unless (length $opts{'m'}) {
				# determine printf width of both whole and
				# fractional portions simultaneously; this will
				# not print decimals for exclusively whole
				# number matrices
				my ($wmax, $dmax) = (0) x 2;
				foreach my $elem ($m->as_list) {
					my ($w, $d) = length int $elem;
					$d = (length $elem) - $w;
					--$d if $d;

					$wmax = $w if $w > $wmax;
					$dmax = $d if $d > $dmax;
				}

				$elem_pat = "%${wmax}.${dmax}f";
			} else {
				$elem_pat = $opts{'m'};
			}

			# form the pattern that will output all matrix elements
			# at once; does this by generating a pattern like so:
			#
			# given that $elem_pat is '%1f' and the matrix $m
			# contains three rows and two columns, then $pat is set
			# to:
			#
			# "[ %1f %1f ]\n".
			# "[ %1f %1f ]\n".
			# "[ %1f %1f ]"
			#
			# Therefore, since the matrix $m contains 6 (3*2)
			# elements, then using the `as_list' subroutine of the
			# matrix object, which returns all elements in list
			# form, will hit and be formatted by all the values in
			# $pat.

			my $pat = join "\n", (
				join ' ', ('[', ($elem_pat) x $m->cols, ']')
			) x $m->rows;

			push @out, sprintf $pat, $m->as_list;
		} else {
			# not a Math::GSL::Matrix object; just return as-is
			push @out, $m;
		}
	}

	wantarray ? @out : join "\n", @out
}

sub _arrayref_to_string {

	my @out;

	foreach my $m (@_) {
		if (ref $m eq 'ARRAY') {

			my $elem_pat = '%s';

			my $pat = join ' ', ('[', ($elem_pat) x @{$m}, ']');

			push @out, sprintf $pat, @{$m};
		} else {
			# not an array ref; just return as-is
			push @out, $m;
		}
	}

	wantarray ? @out : join "\n", @out
}

=head1 SEE ALSO

perlop(1), Math::GSL::Matrix(3), Math::GSL::Const(3), Math::BigInt(3),
Math::BigFloat(3), Term::ANSIColor(3)

=head1 COPYRIGHT

Copyright (C) 2010-2014 Dan Church.

License GPLv3+: GNU GPL version 3 or later
(L<http://gnu.org/licenses/gpl.html>).

This is free software: you are free to change and redistribute it.

There is NO WARRANTY, to the extent permitted by law.

=head1 AUTHOR

Written by Dan Church S<E<lt>amphetamachine@gmail.comE<gt>>

=cut
