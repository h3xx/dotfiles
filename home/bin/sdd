#!/bin/bash
# vi: et sts=4 sw=4 ts=4

USAGE() {
    printf 'Usage: %s [OPTIONS] [--] [DIRECTORY]\n' \
        "${0##*/}"
}

HELP_MESSAGE() {
    USAGE
    cat <<EOF
Create a lazy self-deleting directory. I.e. one that uses at(1) to delete
itself at some point in the future.

If DIRECTORY is specified, create that directory, otherwise delete the current
directory.

  -h            Show this help message.
  -d DATE       Set the date(1)-compatible deletion time (default is 'sunday').
  -i            Operate in interactive mode.
  -v            Operate in verbose mode.
  -l            List scheduled deletions instead of scheduling.

Copyright (C) 2019-2022 Dan Church.
License GPLv3: GNU GPL version 3.0 (https://www.gnu.org/licenses/gpl-3.0.html)
with Commons Clause 1.0 (https://commonsclause.com/).
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
You may NOT use this software for commercial purposes.
EOF
}

DELETE_DATE='sunday'
INTERACTIVE=0
VERBOSE=0
MODE='schedule'

while getopts 'hd:ilv' FLAG; do
    case "$FLAG" in
        'h')
            HELP_MESSAGE
            exit 0
            ;;
        'd')
            DELETE_DATE=$OPTARG
            ;;
        'i')
            INTERACTIVE=1
            ;;
        'l')
            MODE='list'
            ;;
        'v')
            VERBOSE=1
            ;;
        *)
            printf 'Unrecognized flag: %s\n' \
                "$FLAG" \
                >&2
            USAGE >&2
            exit 1
            ;;
    esac
done

shift "$((OPTIND-1))"

ask_yn() (
    PROMPT=$1
    DEFAULT=$2
    read -r -p "$PROMPT [$([[ $DEFAULT = 'y' ]] && echo 'Y/n' || echo 'y/N')]? " ANSWER
    [[ $ANSWER =~ [01NYny] ]] || ANSWER=$DEFAULT
    # return
    [[ $ANSWER =~ [1Yy] ]]
)

reinterpret_date() (
    shopt -s extglob nocasematch
    DATE=$1

    # date(1) interprets some times differently than at(1):
    # - date(1) assumes midnight if you give it bare a bare day of the week.
    #   However, with 'tomorrow', 'yesterday', 'next week', etc. date(1)
    #   preserves the time of day.
    #   --> We want to keep the time of day.
    # - date(1) interprets 'friday' on Friday to mean 'today'. at(1) interprets
    #   this as next Friday.
    #   --> We want 'friday' to mean the coming Friday (not today).
    #
    # XXX An undocumented feature of this reinterpretation is you can bypass it
    # by adding a space at the beginning of your date string.

    # Translate, e.g. 'thursday' => 'next thursday <local time in hh:mm:ss>'
    # DO NOT translate 'thu 12:00'
    if [[ $DATE = +(sun|mon|tue|wed|thu|fri|sat)*([a-z]) ]]; then
        # User specified bare day of week.
        DATE="next $DATE $(date +%T)"
    fi
    printf '%s\n' "$DATE"
)

schedule_delete() (
    DIR=${1:-.}
    if [[ $VERBOSE -ne 0 ]]; then
        printf 'Using directory "%s"\n' \
            "$DIR" \
            >&2
    fi
    DELETE_DATE_MODIFIED=$(reinterpret_date "$DELETE_DATE")
    # at(1) requires -t <time> in the format of [[CC]YY]MMDDhhmm[.ss]
    DELETE_TIMESTAMP_FOR_AT=$(date --date="$DELETE_DATE_MODIFIED" +%Y%m%d%H%M.%S)
    if [[ -z $DELETE_TIMESTAMP_FOR_AT ]]; then
        # date(1) was unable to parse this date
        ERROR_DATE=$DELETE_DATE
        if [[ $DELETE_DATE != "$DELETE_DATE_MODIFIED" ]]; then
            ERROR_DATE+=" ($DELETE_DATE_MODIFIED)"
        fi
        printf 'ERROR: Date string %s is uninterpretable\n' \
            "$ERROR_DATE" \
            >&2
        exit 1
    fi

    if [[ ! -e $DIR ]]; then
        if [[ $INTERACTIVE -ne 0 ]]; then
            if ! ask_yn "Create directory \`$DIR'?" y; then
                return 1
            fi
        elif [[ $VERBOSE -ne 0 ]]; then
            printf 'Using directory "%s"\n' \
                "$DIR" \
                >&2
        fi
        mkdir -p -- "$DIR" || return
    fi
    if [[ $INTERACTIVE -ne 0 ]]; then
        DELETE_DATE_HR=$(date --date="$DELETE_DATE_MODIFIED")
        if ! ask_yn "Schedule deletion for $DELETE_DATE_HR?" y; then
            return 1
        fi
    fi
    # - Don't depend on the directory being there at runtime (at(1) cd's to the
    #   directory you execute at(1) from job runtime).
    # - Pass the directory in as an environment variable, since that's the
    #   safest.
    # - Fix permissions on any stubborn (non-traversable or non-writable)
    #   directories before removing.
    # XXX Note \; instead of + in the first -exec ensures we're modifying
    # permissions to non-traversable directories as we traverse the tree.
    export SDD_DIR=$(realpath -- "$DIR")
    cat <<'EOF' |
if [ -d "$SDD_DIR" ]; then
    find "$SDD_DIR" \
        -type d \
        \( \
            ! \( -executable -readable \) \
            -exec chmod +rwx -- {} \; \
            -o \
            ! -writable \
            -exec chmod +w -- {} + \
        \)
fi
rm -rf -- "$SDD_DIR"
EOF
        (cd /; at -t "$DELETE_TIMESTAMP_FOR_AT")
)

from_now() (
    TS=$1
    NOW=$2
    PRECISION=8

    rpt() {
        printf '%d %s%s ' "$1" "$2" \
            "$([[ $1 -gt 1 ]] && echo 's')"
    }
    DIFF=$(( TS - NOW ))
    if [[ $DIFF -lt 0 ]]; then
        DESC='ago'
    else
        DESC='from now'
    fi
    _DAYS=$(( DIFF / 3600 / 24 ))
    _HOURS=$((DIFF % (3600 * 24) / 3600))
    _MINUTES=$(( DIFF % 3600 / 60 ))
    _SECONDS=$(( DIFF % 60 ))
    if [[ $PRECISION -gt 0 && $_DAYS -gt 0 ]]; then
        rpt "$_DAYS" 'day'
        (( --PRECISION ))
    fi
    if [[ $PRECISION -gt 0 && $_HOURS -gt 0 ]]; then
        rpt "$_HOURS" 'hour'
        (( --PRECISION ))
    fi
    if [[ $PRECISION -gt 0 && $_MINUTES -gt 0 ]]; then
        rpt "$_MINUTES" 'minute'
        (( --PRECISION ))
    fi
    if [[ $PRECISION -gt 0 && $_SECONDS -gt 0 ]]; then
        rpt "$_SECONDS" 'second'
        (( --PRECISION ))
    fi
    printf '%s' "$DESC"
)

list_scheduled() (
    NOW=$(date +%s)

    atq |
        grep -w -- "$USER$" | # Limit to the current user
        while IFS= read -r LINE; do
            JOBID=${LINE%%[^0-9]*}
            SDD_DIR=$(at -c "$JOBID" |grep ^SDD_DIR |
                # eliminate "SDD_DIR="
                cut -f 2- -d = |
                # eliminate "; export SDD_DIR"
                rev |cut -f 2- -d ';' |rev
            )
            if [[ -n $SDD_DIR ]]; then
                DATE=$(rev <<< "$LINE" |cut -f 3- -d ' ' |rev | cut -f 2-)
                TS=$(date +%s --date="$DATE")
                printf '%d\t#%d %s (%s)\n' \
                    "$TS" \
                    "$JOBID" \
                    "$SDD_DIR" \
                    "$(from_now "$TS" "$NOW")"
            fi
        done |
        sort -n |
        # Eliminate UNIX timestamp column (only used for sorting)
        cut -f 2-
)

if [[ $MODE = 'list' ]]; then
    list_scheduled "$@"
else
    schedule_delete "$@"
fi
