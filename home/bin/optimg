#!/bin/bash
# vi: et sts=4 sw=4 ts=4

# optimize image files for size

# CHANGES:
#
# 2015-0602-1428 :
#   * Automatically rotate images from Exif orientation when stripping Exif.
#
# 2011-1211-1210 :
#   * Add `-C' option to not reduce the color type. I've encountered some
#     programs that will not read images with a color palette (namely
#     stella and sometimes even gimp). This method is preferable to using
#     the PREFER_PNGCRUSH method.
#
# 2011-1124-1225 :
#   * Added support for using pngcrush over optipng(1) via the environment
#     variable `PREFER_PNGCRUSH'. pngcrush may not work as well, but it
#     still has its merits as it doesn't insist on re-factoring the color
#     map, a process which can cause errors in some programs.
#
# 2011-0814-1808 :
#   * Added support for omitting the preservation of timestamps via the
#     `-T' option.
#   * Fixed bug in reporting section that was causing individual filenames
#     not to be printed.
#   * Errs out if it can't preserve Exif information. This is because the
#     user specifically requests to save this information, and if we can't
#     do it, the user would most likely be pissed off we optimized the
#     image but dumped the Exif.
#
# 2011-0802-2333 :
#   * Commented out MNG support, as advmng(1) seems to kill the image's
#     usability.
#
# 2011-0802-2308 :
#   * [REDACTED] Now supports optimizing MNG files via advmng(1).
#
# 2011-0725-2201 :
#   * Tests for the existence of jhead(1), jpegtran(1) and gifsicle(1) as
#     they aren't necessarily commonly-distributed programs. jpegtran(1)
#     has the highest probability of being installed as it is part of the
#     libjpeg package.
#   * Specifying `-r' will now recursively process ONLY directories and
#     not specifying it will process ONLY files. Perhaps one day, that
#     piped file list I mention in BUGS will allow both, but for now
#     recursive and non-recursive are mutually exclusive.
#   * Fixed bugs relating to recursing directories starting with a hyphen.
#   * More efficient file size counting in file_size() via better stat(1)
#     arguments.
#   * Fixed text formatting of the help message.
#   * Hardier cpu core count detection for if the kernel hackers ever
#     change the format of /proc/cpuinfo. This also fixes a potentially
#     dangerous bug related to piping a big list of files to xargs(1) when
#     `--max-procs=0', which will cause xargs to process ALL the jobs at
#     once.
#   * Short-circuited the parallel processing operation if the number of
#     jobs/CPU cores is equal to 1.
#   * Recursive operation actually works well now.
#   * More GNU-style messages.
#
# 2011-0718-2328 :
#   * More and better documentation. Now all the functions have header
#     documentation.
#   * Longer options to incidental program calls.
#   * Numerous warnings about recursion pitfalls and inherent bugs.
#   * Bug workaround:
#       pngcrush(1), jpegtran(1) and jhead(1) have no way of accepting
#       file arguments starting with a dash (`-'). This is not my
#       fault.
#     Now the filename is passed through readlink(1) so that it only
#     processes absolute paths, which [should] never start with a hyphen.
#   * Workarounds for a few minor security holes.
#   * Outputs human-readable sizes.
#   * Short-circuited the file_size() function so it's not doing shell math
#     where it doesn't need to.
#   * Recursive operation via find(1) (recursive_selfcall()) now self-calls
#     with `-q' if it was specified when starting the script.
#
# 2010-0715-1300 :
#   * Now counts freed bytes via stat(1).
#   * Included -q option for quiet operation.
#   * Included -r and -x EXTENSION option for recursive scheduling.
#     Recursive scheduling now supercedes normal scheduling.
#   * Removed -s option for single files (previously used when scheduling);
#     now relies on value of `$#' to determine whether more than one file
#     was indicated on the command line.
#
# 2010-0321-2044 :
#   * Now uses parallel processes via xargs(1).
#
# 2010-0125-2015 :
#   * Fixed some bugs/modularity issues regarding local variables in
#     functions.
#   * Included support for [more advanced] optipng(1). It is now preferred
#     over pngcrush(1) as it seems to do a better job.
#
# BUGS:
#   * Doesn't do that great a job of counting freed bytes on larger
#     operations using the `-r' (recursive) flag. This is due to find(1)
#     sending only-so-many file names to the command when using the `-exec
#     [COMMAND] [ARGS] {} +' syntax. Perhaps implementing a piped file
#     list would solve it.
#   * hr_size() function does not round its figures; it only truncates
#     them. This is due to its only using the built-in shell math
#     functionality, which is only capable of integer math.
#

USAGE() {
    cat <<EOF
Usage: ${0##*/} [OPTIONS] [--] FILE...
       ${0##*/} [OPTIONS] -r [--] [DIR]...
EOF
}

HELP_MESSAGE() {
    USAGE
    cat <<EOF
Optimize image files for size.

  -h        Show this help message.
  -e        Preserve Exif metadata in JPEG files using jhead(1).
  -j NUM    Run at maximum NUM simultaneous operations. This defaults to
              the auto-detected number of processors/virtual cores in the
              system.
  -q        Be quiet. Produce only error messages on STDERR.
  -r        Optimize all images found by recursing DIRs. File arguments
              are ignored.
  -x SUF    When optimizing recursively via the \`-r' flag, only operate
              on files whose names match /.*SUF/. May be specified
              multiple times. Also accepts POSIX-compatible regular
              expressions. If not specified, recursive operations will
              operate on all files.
  -T        Do not preserve timestamp information on optimized images.
              Default is to preserve as much as possible.
  -C        Be careful when optimizing PNGs. Sometimes reducing a PNG's
              color map can cause it to be displayed incorrectly. Most
              programs can handle it, however.
  --        Terminate options list.

Currently, this script will only work on the following types of files:
  * JPEG (\`image/jpeg')                         Using jpegtran(1)
  * Portable Network Graphics (\`image/png')     Using optipng(1)/pngcrush
  * Mult-image Network Graphics (\`video/x-mng') Using advmng(1) [not working]
  * Graphics Interchange Format (\`image/gif')   Using gifsicle(1)

  If the environment variable PREFER_PNGCRUSH is set to a non-empty value, then
  pngcrush is preferred over optipng(1).

Copyright (C) 2010-2015 Dan Church.
License GPLv3+: GNU GPL version 3 or later (http://gnu.org/licenses/gpl.html).
This is free software: you are free to change and redistribute it. There is NO
WARRANTY, to the extent permitted by law.
EOF
}

KEEP_EXIF=0
# determine number of jobs from number of CPU cores in the system
NUM_JOBS=$(
    CPUDETECT=0
    if [[ -r /proc/cpuinfo ]]; then
        CPUDETECT=$(
            grep -c '^processor' '/proc/cpuinfo'
        )
    fi
    if [[ $CPUDETECT -gt 0 ]]; then
        echo "$CPUDETECT"
    else
        echo 1
    fi
)
QUIET=0
RECURSIVE=0
EXTS=()
PRESERVE_TIMESTAMP=1
CAREFUL=0

# XXX Note to self: when adding options, make sure to update
# recursive_selfcall() and schedule_process()
while getopts 'hej:qrx:TC-' FLAG; do
    case "$FLAG" in
        'e')
            KEEP_EXIF=1
            ;;
        'j')
            NUM_JOBS=$OPTARG
            ;;
        'q')
            QUIET=1
            ;;
        'r')
            RECURSIVE=1
            ;;
        'x')
            EXTS+=("$OPTARG")
            ;;
        'T')
            PRESERVE_TIMESTAMP=0
            ;;
        'C')
            CAREFUL=1
            ;;
        'h')
            HELP_MESSAGE
            exit 0
            ;;
        *)
            printf 'Unrecognized flag: %s\n' \
                "$FLAG" \
                >&2
            USAGE >&2
            exit 1
            ;;
    esac
done

shift "$((OPTIND-1))"

TEMP_FILES=()

cleanup() {
    rm -f -- "${TEMP_FILES[@]}"
}

trap 'cleanup' EXIT

# prints out the sum of the sizes, in bytes of all files passed to it
file_size() {
    if [[ $# -gt 1 ]]; then
        # adds all the file sizes by doing a stat on all of them
        # (separated by `\n'), transforming them into
        # `LINE+LINE+...LINE+0' and passing them to the Bash expression
        # evaluator
        echo "$(($(
            stat \
                --printf='%s+' \
                --dereference \
                -- \
                "$@" 2>/dev/null
        )0))"
    else
        # only got one file to check; do it simply
        stat \
            --format='%s' \
            --dereference \
            -- \
            "$@" 2>/dev/null
    fi
}

# produces a human-readable size from the byte count passed to it
hr_size() (
    declare -i BYTES=$1
    if type hr_size.sh &>/dev/null; then
        hr_size.sh "$BYTES"
    else
        printf '%d bytes\n' \
            "$BYTES"
    fi
)

# prints out the simple mimetype (e.g. `image/jpeg') of a file's contents
get_mimetype() {
    # XXX file(1) doesn't always produce the correct mimetype for files;
    # possible workaround would be to include `--magic-file
    # /etc/file/magic/images'
    file \
        --preserve-date \
        --dereference \
        --brief \
        --mime-type \
        -- \
        "$@" 2>/dev/null
}

# copies $2 over to $1 if $2 is smaller than $1
use_smaller() {
    # if `$TEMP' isn't empty and it's of a smaller size than `$FILE', preserve
    # every attribute and replace `$FILE' with `$TEMP'
    local \
        FILE=$1 \
        TEMP=$2 \
        ORIGSIZE \
        TEMPSIZE

    ORIGSIZE=$(file_size "$FILE")
    TEMPSIZE=$(file_size "$TEMP")

    if [[
        -f "$TEMP"
        && $TEMPSIZE -gt 0
        && $TEMPSIZE -lt $ORIGSIZE
    ]]; then

        # preserve attributes by copying them from the original file to
        # the temporary one
        chmod \
            --reference="$FILE" \
            -- \
            "$TEMP" &&

        if [[ $PRESERVE_TIMESTAMP -ne 0 ]]; then
            touch \
                --reference="$FILE" \
                -- \
                "$TEMP" ||
            return
        fi &&

        if [[ $UID -eq 0 ]]; then
            # we are root, so we can chown(1) things
            chown \
                --reference="$FILE" \
                -- \
                "$TEMP" ||
            return
        fi &&

        cp \
            --preserve=mode,ownership,timestamps \
            -- \
            "$TEMP" \
            "$FILE" &&

        local ERR=$?
        case "$ERR" in
            '0')
                printf 'optimized image `%s'\''\n' \
                    "$FILE" \
                    >&2
                ;;
            *)
                printf 'failed to optimize `%s'\''!\n' \
                    "$FILE" \
                    >&2
                ;;
        esac

    fi

    # protect against unsuccessful following file writes to our temp file
    rm \
        --force \
        -- \
        "$TEMP"

}

# optimize a single[*] image file--any image file it can
#
# *: can handle multiple files
optimize_image() {
    local \
        IMAGE_FILE \
        TEMP

    for IMAGE_FILE; do

        [[ -f $IMAGE_FILE ]] || continue

        # get the absolute path of the image file so that ALL filenames
        # can be handled, even ones beginning with a hyphen
        IMAGE_FILE=$(readlink -f -- "$IMAGE_FILE")

        TEMP=$(mktemp -t "${0##*/}.XXXXXX")
        TEMP_FILES+=("$TEMP")

        case "$(get_mimetype "$IMAGE_FILE")" in

'image/jpeg')

    # XXX jpegtran and jhead cannot handle input files starting with -

    local TEMP1=$(mktemp -t "${0##*/}.XXXXXX")
    TEMP_FILES+=("$TEMP1")

    cp -a -- "$IMAGE_FILE" "$TEMP1" &&

    # rotate image according to the orientation saved in the Exif information
    # if we are not going to save the Exif information itself
    if [[ $KEEP_EXIF -eq 0 ]]; then
        if hash jhead &>/dev/null; then
            jhead \
                -autorot "$TEMP1" >&2 ||
            return
        fi
    fi &&

    # optimize the image
    if hash jpegtran &>/dev/null; then
        jpegtran \
            -optimize \
            -outfile "$TEMP" \
            "$TEMP1" \
            >&2 ||
        return

    else
        printf 'No supported JPEG optimizer found.\n' \
            >&2
        return 1
    fi &&

    if [[ $KEEP_EXIF -ne 0 ]]; then
        if hash jhead &>/dev/null; then
            # Copy Exif information from original file to the temporary file
            jhead \
                -te "$IMAGE_FILE" \
                "$TEMP" \
                >&2 ||
            return

        else
            # The user specifically requested to save Exif information, so if
            # we can not do it, might as well give an error
            printf 'Error: Cannot preserve Exif information.\n' \
                >&2
            return 1
        fi
    fi &&

    use_smaller "$IMAGE_FILE" "$TEMP"

    ;;

'image/png')

    # truth table:
    # prefpc| has_pngcrush  | has_optipng   | method
    # 0 | 0     | 0     | exit
    # 0 | 0     | 1     | optipng
    # 0 | 1     | 0     | pngcrush
    # 0 | 1     | 1     | optipng
    # 1 | 0     | 0     | exit
    # 1 | 0     | 1     | optipng
    # 1 | 1     | 0     | pngcrush
    # 1 | 1     | 1     | pngcrush
    #
    # optipng = (!prefpc -o !has_pngcrush) && has_optipng
    if (
        [[ -z $PREFER_PNGCRUSH ]] ||
        ! hash pngcrush &>/dev/null
    ) && hash optipng &>/dev/null; then

        # XXX optipng refuses to overwrite files (even though the man page says
        # -force overrides this)
        rm -f -- "$TEMP" &&

        optipng \
            $([[ $QUIET -eq 0 ]] || echo ' -quiet') \
            $([[ $CAREFUL -eq 0 ]] || echo ' -nc') \
            -o7 \
            -fix \
            -force \
            -out "$TEMP" \
            -- \
            "$IMAGE_FILE" >&2 ||
        return

    elif hash pngcrush &>/dev/null; then

        # XXX pngcrush cannot handle input files starting with -
        pngcrush \
            $([[ $QUIET -eq 0 ]] || echo '-q') \
            -brute \
            "$IMAGE_FILE" \
            "$TEMP" >&2 ||
        return

    else
        printf 'No supported PNG optimizer found.\n' \
            >&2
        return 1
    fi &&

    use_smaller "$IMAGE_FILE" "$TEMP"

    ;;

'video/x-mng')

    #if hash advmng &>/dev/null; then
    #   # advmng optimizes files in-place, but we want to be more
    #   # careful than that
    #   cp -- "$IMAGE_FILE" "$TEMP" &&
    #
    #   advmng \
    #       --recompress \
    #       --shrink-fast \
    #       --force \
    #       $([[ $QUIET -eq 0 ]] || echo '--verbose') \
    #       -- \
    #       "$TEMP" ||
    #   return
    #
    #   # XXX sometimes advmng fucks up the MNG so work around it by having it
    #   # re-check its work
    #   advmng \
    #       --list \
    #       -- \
    #       "$TEMP" ||
    #   return
    #
    #else
    #   printf 'No supported MNG optimizer found.\n' >&2
    #   exit 1
    #fi &&
    #
    #use_smaller "$IMAGE_FILE" "$TEMP"

    # FIXME : advmng is really, REALLY old and is kind of shit at the whole
    #     not-fucking-up-your-images thing
    printf 'Sorry, support for MNG is not yet implemented.\n' \
        >&2

    ;;

'image/gif')

    if hash gifsicle &>/dev/null; then
        # XXX this opens up a [very minor] symlink attack vector: if "$TEMP" is
        # replaced with a symlink during execution, its target will be
        # clobbered with the output from gifsicle(1)
        rm --force -- "$TEMP" &&

        gifsicle \
            --optimize=3 \
            --output "$TEMP" \
            "$IMAGE_FILE" \
            >&2 ||
        return

    else
        printf 'No supported GIF optimizer found.\n' \
            >&2
        return 1
    fi &&

    use_smaller "$IMAGE_FILE" "$TEMP"

    ;;

*)

    printf 'Image type of `%s'\'' not recognized.\n' \
        "$IMAGE_FILE" \
        >&2
    ;;

        esac
    done
}

# process multiple files in parallel processes
#
# schedules the filenames passed to the function to execute in parallel by
# calling this script for each file
#
# this function only runs if there are multiple files specified on the
# command line
#
# XXX it is VERY IMPORTANT that the self-calls initiated here are given only
# one file argument or this script will loop recursively forever
schedule_process() {
    local \
        XARGS_OPTS \
        SELF_ARGS \
        FILE

    # Initial options
    XARGS_OPTS=(
        # accept null-terminated list
        '--null'
        # send only one list item for each process (VERY IMPORTANT!!!)
        '--max-args=1'
        # execute on parallel process per core
        "--max-procs=$NUM_JOBS"
        # terminate option list
        '--'
    )

    SELF_ARGS=()

    if [[ $KEEP_EXIF -ne 0 ]]; then
        SELF_ARGS+=('-e')
    fi

    if [[ $PRESERVE_TIMESTAMP -eq 0 ]]; then
        SELF_ARGS+=('-T')
    fi

    if [[ $QUIET -ne 0 ]]; then
        SELF_ARGS+=('-q')
    fi

    if [[ $CAREFUL -ne 0 ]]; then
        SELF_ARGS+=('-C')
    fi

    # Terminate options list
    SELF_ARGS+=('--')

    SELF_EXEC=(
        "$0"
        "${SELF_ARGS[@]}"
    )

    # Add the self-execution to what xargs(1) executes
    XARGS_OPTS+=(
        "${SELF_EXEC[@]}"
    )

    # translate into null-separated list for maximum xargs security
    for FILE; do
        printf '%s\0' "$FILE"
    done |

    # pipe it to xargs which will perform the scheduling, passing one file to
    # another running copy of this script
    # XXX it is VERY important that only ONE file get passed or the script will
    # get stuck in an infinite recursion loop
    xargs "${XARGS_OPTS[@]}"
}

# process a single file
#
# should run only if the script is given only one argument, which happens when
# the script is self-executed via xargs(1) from the schedule_process() function
single_process() {
    optimize_image "$@"
}

# process directories recursively
#
# sends all[*] files, optionally matching a given regex, located in the
# directories given to a recursive call to this script, whereby the
# schedule_process() function receives them and processes them in parallel
#
# *: does not send all files at once; there ARE system limits you know...
#    but that doesn't mean that not all files get processed--the list just
#    gets split up and sent to multiple self-invocations
recursive_selfcall() {
    local \
        DIRNAMES \
        DIR \
        FIND_PARAMS \
        SELF_EXEC \
        SELF_ARGS

    # Transform directories passed in into absolute paths in order to
    # correctly process directory arguments beginning with a hyphen
    DIRNAMES=()
    for DIR; do
        DIRNAMES+=("$(readlink -f -- "$DIR")")
    done

    # Initial options
    FIND_PARAMS=(
        # don't dereference symlinks
        '-P'
        # search directories (expands to either quoted arguments to this
        # function, or `.')
        "${DIRNAMES[@]:-.}"
        '-type' 'f'
    )

    # Add regex to match file extensions if specified with `-x'
    if [[ ${#EXTS[@]} -gt 0 ]]; then
        FIND_PARAMS+=(
            '-regextype' 'posix-egrep'
            '-regex' '.*\.('"${EXTS[*]/#.}"')'
        )
    fi

    SELF_ARGS=(
        # Always-set option
        '-j' "$NUM_JOBS"
    )

    # Pass option switches to self (except for `-r' and `-x`)
    if [[ $KEEP_EXIF -ne 0 ]]; then
        SELF_ARGS+=('-e')
    fi

    if [[ $PRESERVE_TIMESTAMP -eq 0 ]]; then
        SELF_ARGS+=('-T')
    fi

    if [[ $QUIET -ne 0 ]]; then
        SELF_ARGS+=('-q')
    fi

    if [[ $CAREFUL -ne 0 ]]; then
        SELF_ARGS+=('-C')
    fi

    SELF_ARGS+=('--')   # terminate options list

    SELF_EXEC=(
        '-exec' "$0"
        "${SELF_ARGS[@]}"
        # Make sure our clone gets sent all the matching files
        '{}' '+'
    )

    FIND_PARAMS+=(
        "${SELF_EXEC[@]}"
    )

    # Now the call to find(1) is simple! (haha)
    find "${FIND_PARAMS[@]}"
}

# Separate directory arguments from files
ARG_DIRS=()
ARG_FILES=()
for ARG; do
    if [[ -d $ARG ]]; then
        ARG_DIRS+=("$ARG")
    elif [[ -f $ARG ]]; then
        ARG_FILES+=("$ARG")
    else
        printf 'Unknown filetype `%s'\''\n' \
            "$ARG" \
            >&2
    fi
done

# If only a single filename was passed in, then we're [most likely] being
# called from xargs; otherwise, we're scheduling

if [[ $RECURSIVE -ne 0 ]]; then
    if [[ $QUIET -eq 0 ]]; then
        recursive_selfcall "${ARG_DIRS[@]}"
    else
        recursive_selfcall "${ARG_DIRS[@]}" &>/dev/null
    fi
else
    # No arguments; print out help message like the friendlier
    # command-line utilities
    if [[ $# -eq 0 ]]; then
        HELP_MESSAGE
        exit 0
    fi

    if [[ ${#ARG_FILES[@]} -eq 0 ]]; then
        printf 'No files to process.\n' \
            >&2
        if [[ ${#ARG_DIRS[@]} -ne 0 ]]; then
            printf '(Use `-r'\'' to process directories.)\n' \
                >&2
        fi
        # obligatory stereotypical GNU-style message
        printf 'Try `%s --help'\'' for more information.\n' \
            "${0##*/}" \
            >&2
        exit 2
    fi

    BEGIN_FILESIZE=$(file_size "${ARG_FILES[@]}")

    if [[ ${#ARG_FILES[@]} -eq 1 || $NUM_JOBS -eq 1 ]]; then

        # Only one file or one job specified; no need to run parallel
        # processes
        single_process "${ARG_FILES[@]}"

        if [[ ${#ARG_FILES[@]} -eq 1 ]]; then
            REPORT_NAME=${ARG_FILES[0]}
        else
            REPORT_NAME='all'
        fi

    else
        # Multiple files specified; process them in parallel
        if [[ $QUIET -eq 0 ]]; then
            schedule_process "${ARG_FILES[@]}"
        else
            schedule_process "${ARG_FILES[@]}" &>/dev/null
        fi

        REPORT_NAME='all'

    fi

    END_FILESIZE=$(file_size "${ARG_FILES[@]}")

    FREED=$(( BEGIN_FILESIZE - END_FILESIZE ))
    FREED_HR=$(hr_size "$FREED")

    # Note: this must occur on the same line, because otherwise it gets
    # separated during asynchronous operations
    printf '%s: freed %d bytes (%s)\n' \
            "$REPORT_NAME" \
            "$FREED" \
            "$FREED_HR"
fi
