#!/bin/bash
# vi: et sts=4 sw=4 ts=4

shopt -s inherit_errexit
set -e

USE_NETRC=1
NETRC_FILE=
DEFAULT_NETRC_FILE=~/.netrc
VERBOSITY=0
GITHUB_USER=
NEW_REMOTE_NAME=me

USAGE() {
    printf 'Usage: %s [OPTIONS]...\n' \
        "${0##*/}"
}

HELP_MESSAGE() {
    USAGE
    cat <<EOF
Fork a GitHub repo to your own namespace.

  -h, --help        Show this help message.
  -n, --use-netrc, --use-netrc=1
                    Force using .netrc for curl calls. Default on.
  --no-use-netrc, --use-netrc=0
                    Do not use .netrc.
  --github-user=USER
                    Override git config "github.user" setting.
  -v, --verbose     Increase verbosity.
  --                Terminate options list.

Copyright (C) 2022 Dan Church.
License GPLv3: GNU GPL version 3.0 (https://www.gnu.org/licenses/gpl-3.0.html)
with Commons Clause 1.0 (https://commonsclause.com/).
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
You may NOT use this software for commercial purposes.
EOF
}

parse_options() {
    ARGS=()
    local NO_MORE_FLAGS=0
    for ARG; do
        # Assume arguments that don't begin with a - are supposed to be files or other operands
        if [[ $NO_MORE_FLAGS -eq 0 && $ARG = -* ]]; then
            case "$ARG" in
                -n|\
                --use-netrc)
                    USE_NETRC=1
                    ;;
                --no-use-netrc)
                    USE_NETRC=0
                    ;;
                --use-netrc=*)
                    case "${ARG#*=}" in
                        [0Nn]*)
                            USE_NETRC=0
                            ;;
                        [1Yy]*)
                            USE_NETRC=1
                            ;;
                        *)
                            printf 'Unrecognized on/off value: %s\n' \
                                "${ARG#*=}" \
                                >&2
                            exit 2
                            ;;
                    esac
                    ;;
                --netrc=*)
                    NETRC_FILE=${ARG#*=}
                    ;;
                --remote-name=*)
                    NEW_REMOTE_NAME=${ARG#*=}
                    ;;
                --github-user=*)
                    GITHUB_USER=${ARG#*=}
                    ;;
                -v|\
                --verbose)
                    ((++VERBOSITY))
                    ;;

                --help|-h)
                    HELP_MESSAGE
                    exit 0
                    ;;
                --)
                    NO_MORE_FLAGS=1
                    ;;
                *)
                    printf 'Unrecognized flag: %s\n' \
                        "$ARG" \
                        >&2
                    USAGE >&2
                    exit 2
                    ;;
            esac
        else
            ARGS+=("$ARG")
        fi
    done

    # Massage empty options
    if [[ -z $GITHUB_USER ]]; then
        GITHUB_USER=$(git config --get github.user || true)
    fi
}

check_options() {

    if [[ $USE_NETRC -ne 0 ]]; then
        # Warn if setup incorrectly
        if ! grep -aPq '^[^#]*\bmachine\s+api.github.com\b' "${NETRC_FILE:-$DEFAULT_NETRC_FILE}"; then
            if [[ $VERBOSITY -gt 0 ]]; then
                cat >&2 <<EOF
To store your password for re-use, add the following lines to ${NETRC_FILE:-$DEFAULT_NETRC_FILE}:

machine api.github.com
 login ${GITHUB_USER:-'<GITHUB USER>'}
 password <MY_GITHUB_TOKEN - see https://github.com/settings/tokens>
EOF
            fi
        fi
    fi

    if [[ -z $GITHUB_USER ]]; then
        printf 'Git config github.user is empty!\nUse "git config --global github.user <USERNAME>" to set it.\n' \
            >&2
        exit 1
    fi
}

main() (
    parse_options "$@"
    check_options

    CURL_OPTS=(
        # -q, --disable: Disable ~/.curlrc
        -q
        --no-progress-meter
    )
    if [[ -n $NETRC_FILE ]]; then
        CURL_OPTS+=(
            --netrc-file "$NETRC_FILE"
        )
    fi
    if [[ $USE_NETRC -ne 0 ]]; then
        CURL_OPTS+=(
            --netrc
        )
    else
        CURL_OPTS+=(-u "$GITHUB_USER")
    fi

    SOURCE_NAMESPACE=$(github_namespace)
    NEW_NAMESPACE=$GITHUB_USER/${SOURCE_NAMESPACE#*/}
    NEW_REMOTE_URL=git@github.com:$NEW_NAMESPACE.git
    NEW_WEB_URL=https://github.com/$NEW_NAMESPACE.git

    if ! OUT=$(
        curl \
            "${CURL_OPTS[@]}" \
            "https://api.github.com/repos/$SOURCE_NAMESPACE/forks" \
            -d ''
    ); then
        printf 'Failed to fork project:\n%s\n' \
            "$OUT" \
            >&2
    fi

    if [[ $(remote_url "$NEW_REMOTE_NAME" 2>/dev/null || true) != "$NEW_REMOTE_URL" ]]; then
        if [[ $VERBOSITY -gt 0 ]]; then
            printf 'Adding remote "%s" at "%s"\n' \
                "$NEW_REMOTE_NAME" \
                "$NEW_REMOTE_URL" \
                >&2
        fi
        git remote add \
            "$NEW_REMOTE_NAME" \
            "$NEW_REMOTE_URL" || true
    fi

    printf 'Forked to %s\n' \
        "$NEW_WEB_URL" \
        >&2
)

remote_for_branch() (
    # TODO replace with `git branch --show-current` when more widely available
    BRANCH=${1:-$(git rev-parse --abbrev-ref HEAD || true)}
    if [[ -z $BRANCH ]]; then
        printf 'fatal: could not determine upstream of HEAD when it does not point to any branch.\n' \
            >&2
        exit 128
    fi

    REMOTE=$(git config --local "branch.$BRANCH.remote" || true)
    if [[ -z $REMOTE ]]; then
        printf 'fatal: could not determine upstream of %s when it does not have an upstream set.\n' \
            "$BRANCH" \
            >&2
        exit 128
    fi
)

remote_url() (
    REMOTE=$1
    URL=$(git remote get-url "$REMOTE")
    if [[ -z $URL ]]; then
        printf 'fatal: could not determine URL of remote %s.\n' \
            "$REMOTE" \
            >&2
        exit 128
    fi

    printf '%s\n' "$URL"
)

validate_github_url() (
    URL=$1
    if [[ $URL != *github.com* ]]; then
        printf 'URL is not a GitHub URL: %s\n' \
            "$URL" \
            >&2
        exit 1
    elif [[ $URL = *github.com[:/]"$GITHUB_USER"* ]]; then
        printf 'URL is already under namespace %s: %s\n(Possibly already forked)\n' \
            "$GITHUB_USER" \
            "$URL" \
            >&2
        exit 1
    fi
)

github_namespace() (
    BRANCH=$1
    REMOTE=$(remote_for_branch "$BRANCH" 2>/dev/null || true)
    URL=
    if [[ -n $REMOTE ]]; then
        TEST=$(remote_url "$REMOTE")
        if validate_github_url "$TEST"; then
            URL=$TEST
        fi
    fi

    # Try all remotes
    if [[ -z $URL ]]; then
        for REMOTE in $(git remote show); do
            TEST=$(remote_url "$REMOTE")
            if validate_github_url "$TEST"; then
                URL=$TEST
                break
            fi
        done
    fi

    if [[ -z $URL ]]; then
        printf 'fatal: No remotes with possible GitHub URL found\n' \
            >&2
        exit 128
    fi

    # Examples:
    # - https://github.com/user/project.git
    # - git@github.com:user/project.git
    NS=${URL#*[@/]github.com[:/]}
    if [[ $NS = "$URL" ]]; then
        printf 'fatal: Unable to determine GitHub namespace from URL: %s\n' \
            "$URL" \
            >&2
        exit 128
    fi
    NS=${NS%.git}

    printf '%s\n' "$NS"
)

main "$@"
